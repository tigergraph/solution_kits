CREATE QUERY tg_wcc_merchant_weight_based (
  //STRING v_type_set = "Merchant", 
  //STRING e_type_set = "Merchant_Merchant", 
  INT print_limit = 100,
  BOOL print_results = TRUE, 
  STRING result_attribute = "c_id")  {

    /*
       This query determines the connected components within a graph using undirected edges. Upon completion, each vertex 
       is assigned an integer label that corresponds to its component ID number. Subsequently, edges are inserted between 
       each vertex within a community and other vertices that share the same component ID as this community.
    
    
    TigerGraph Documentation:
        https://docs.tigergraph.com/graph-ml/current/community-algorithms/connected-components

    Parameters:
        v_type_set:
            vertex types to traverse
            -- v_type_set = "Merchant" when run wcc for Merchant community
            -- v_type_set = "Card" when run wcc for Card community 
        print_results:
            If True, print JSON output
        e_type_set:
            edge types to traverse
            -- e_type_set = "Merchant_Merchant" when run wcc for Merchant community
            -- e_type_set = "Card_Card" when run wcc for Card community 
        result_attribute:
            INT attribute to store results to
        file_path:
            file to write CSV output to
        display_edges:
            output edges for visualization
        print_limit:
            maximum number of vertices to output (-1 = all)
    */

/*
 This query identifies the Connected Components (undirected edges). When finished, each
 vertex is assigned an INT label = its component ID number.
  v_type_set: vertex types to traverse          print_results: print JSON output
  e_type_set: edge types to traverse            result_attribute: INT attribute to store results to
  file_path: file to write CSV output to    display_edges: output edges for visualization
  print_limit: max #vertices to output (-1 = all)  
*/

MinAccum<INT> @min_cc_id = 0;       //each vertex's tentative component id
MapAccum<INT, INT> @@comp_sizes_map;
MapAccum<INT, ListAccum<INT>> @@comp_group_by_size_map;
MaxAccum<FLOAT> @@max_weight;
MinAccum<FLOAT> @@min_weight;
 
// reset merchant community id

Start = SELECT s 
        FROM Merchant:s
  POST-ACCUM 
      IF result_attribute != "" THEN 
          s.setAttr(result_attribute, 0) END;
    
//delete previous Community_Merchant edges
    dlt =SELECT s 
      FROM Community:s -(Has_Community:e)- Merchant:m 
      ACCUM delete(e);
# Initialize: Label each vertex with its own internal ID
S = SELECT x 
    FROM Start:x
    POST-ACCUM x.@min_cc_id = getvid(x);
    
S = SELECT s
        FROM Merchant:s -(Merchant_Merchant:e)- Merchant:t
        ACCUM @@max_weight += e.weight, @@min_weight += e.weight;
INT community_factor = 10;
FLOAT rng = @@max_weight - @@min_weight;
FLOAT seg = rng / community_factor ;   
INT i= 1; 
    PRINT rng, seg,@@max_weight;
remaining = {Merchant.*};
# Propagate smaller internal IDs until no more ID changes can be Done
WHILE (i<= community_factor) DO
    WHILE (S.size()>0) DO
    S = SELECT t
        FROM remaining:s -(Merchant_Merchant:e)- remaining:t
        WHERE e.weight >= (@@max_weight - i*seg)
	ACCUM t.@min_cc_id += s.@min_cc_id // If s has smaller id than t, copy the id to t
	HAVING t.@min_cc_id != t.@min_cc_id'; 
    END;
    S = SELECT t
        FROM remaining:s -(Merchant_Merchant:e)- remaining:t
        WHERE e.weight >= (@@max_weight - i*seg);
    PRINT S.size();
    remaining = remaining MINUS S; 
    i=i+1;
    PRINT remaining.size();
END;
S = SELECT t
        FROM remaining:s -(Merchant_Merchant:e)- remaining:t
        WHERE e.weight >= (@@max_weight - i*seg);

Start = SELECT s 
        FROM Merchant:s
	POST-ACCUM 
	    IF result_attribute != "" THEN 
	        s.setAttr(result_attribute, s.@min_cc_id) 
	    END,
	    
	    IF print_results THEN 
	        @@comp_sizes_map += (s.@min_cc_id -> 1) 
	    END;
#insert connected component edges

    tmp = SELECT s 
      FROM Merchant:s 
      POST-ACCUM
        INSERT INTO Community VALUES (s.@min_cc_id),
        INSERT INTO Has_Community VALUES (s,s.@min_cc_id);
    
    
  IF print_results THEN
    IF print_limit >= 0 THEN
        Start = SELECT s 
                FROM Start:s 
                LIMIT print_limit;
    END;
    FOREACH (compId,size) IN @@comp_sizes_map DO
        @@comp_group_by_size_map += (size -> compId);
    END;
    PRINT @@comp_group_by_size_map;
    PRINT @@comp_sizes_map as sizes;
    PRINT Start[Start.@min_cc_id];
END;
}